{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/patterns.coffee"
  ],
  "names": [],
  "mappings": "AAyDG;EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAEH,IAAC,CAAA,QAAD,GAAY;IAAE,GAAA,EAAK,CAAA,CAAP;IAAW,IAAA,EAAM,CAAA;EAAjB,EAFT;;;;;EAOH,IAAC,CAAA,QAAQ,CAAC,GAAG,CAAC,KAAd,GAAsB;;EAStB,IAAC,CAAA,QAAQ,CAAC,IAAI,CAAC,KAAf,GAAgC,MAAA,CAAA,CAAA,CAAA,CAAA,CAAiB,IAAC,CAAA,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,MAArC,CAAA,CAAA,CAAA,EAAkE,GAAlE;;EAChC,IAAC,CAAA,QAAQ,CAAC,IAAI,CAAC,cAAf,GAAgC,MAAA,CAAA,CAAA,UAAA,CAAA,CAAiB,IAAC,CAAA,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,MAArC,CAAA,aAAA,CAAA,EAAkE,GAAlE;AAjB7B",
  "sourcesContent": [
    "\n###\n\nPatterns to recognize some literals\n\n* **`patterns.only.float`**:\n  * **NOTE** one could think that float literals, being so ubiquitous in programming languages, are a\n    'solved problem' in terms of a widely shared set of views of what should and what should not constitute\n    a valid representation of an optionally signed, optionally fractional, optionally exponentiated\n    numerical value, but not so. Some standards are too rigid, e.g. JSON does not allow plus signs in front\n    of number literals; some standards are like early internet RFCs in that they want to allow any bad idea\n    that any programmer has ever come up with, intentionally, out of sloppyness or due to a misguided sense\n    of 'efficiency' (as in, `123` is an integer literal but `123.` is a float—we just saved the world by\n    omitting a `0`). At other times, sensible things like using optional leading zeros have been frustrated\n    by the equally misguided idea of engineers of old that leading zeros should indicate octal literals.\n    After some deliberation, we settled on the below set of accepted and rejected literals, here shown as\n    examples. In the end, `patterns.only.float` will recognize almost anything for which the JS `eval()`\n    function returns a numerical value (to the exclusion of `Infinity` and trailing decimal points).\n  * `patterns.only.float` will **recognize** literals that look like the following examples:\n    * `123`\n    * `123.45`\n    * `45e43`\n    * `.45`\n    * `.45e43`\n    * `.45e+43`\n    * `.45e-43`\n    * `+.45`\n    * `+.45e43`\n    * `+.45e+43`\n    * `+.45e-43`\n    * `-.45`\n    * `-.45e43`\n    * `-.45e+43`\n    * `-.45e-43`\n    * `123e3`\n    * `123.0e3`\n    * `123.4e3`\n    * `+3`\n    * `3.2e23`\n    * `-4.70e+9`\n    * `-.2E-4`\n    * `-7.6603`\n  * `patterns.only.float` will **reject** literals that look like the following examples:\n    * `+0003`:       JS errors with `Octal literals are not allowed in strict mode`\n    * `0003`:        JS errors with `Octal literals are not allowed in strict mode`\n    * `-0003`:       JS errors with `Octal literals are not allowed in strict mode`\n    * `4567.`:       sole trailing dot with no decimals considered bad habit\n    * `e123`:        JS errors with `e123 is not defined`\n    * `e-4`:         JS errors with `e is not defined`\n    * `.e4`:         JS errors with `Unexpected token '.'`\n    * `.45e-43.2`:   JS errors with `Unexpected number`\n    * `45e4৩`:       JS errors with `Invalid or unexpected token`\n    * `37.e88`:      sole trailing dot before the e/E-marked exponent considered bad habit\n    * `123.4.e3`:    JS parses this as attribute access, return `undefined`; it evaluates but should've\n      never been allowed in the first place; JS does allow stuff like `false.d`, `/./.d` &c but these are\n      arguably more border cases / quirks / warts than useful, clear notations\n\n###\n\n@patterns = { any: {}, only: {}, }\n\n#-----------------------------------------------------------------------------------------------------------\n### thx to https://stackoverflow.com/a/51790561/7568091 ###\n### ///^[-+]?([0-9]*[.])?[0-9]+([eE][-+]?[0-9]+)?$/// ###\n@patterns.any.float = ///\n  [-+]?\n  (?:\n    ([1-9][0-9]*[.])[0-9]+ |\n    ([.])[0-9]+ |\n    ([1-9][0-9]*)\n    )\n  ([eE][-+]?[0-9]+)?\n  ///u\n@patterns.only.float          = ///^           #{@patterns.any.float.source}                  $///u\n@patterns.only.float_and_rest = ///^ (?<float> #{@patterns.any.float.source} ) (?<rest> .* )  $///u\n"
  ]
}